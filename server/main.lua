-- [[ XRB-BARTERING SERVER SCRIPT ]]

local QBCore = exports['qb-core']:GetCoreObject()

local currentPedLocationIndex = 1
local contractsCompletedAtCurrentLocation = 0
local playerActiveContracts = {} -- [source] = { contractId, contractData, endTime }
local currentShopStock = {} -- [shopId] = { {name, price, currency, stock}, ... }
local shopRefreshTimer = nil

-- [[ FUNKSIONET E DATABAZES  ]]
local function getDbPlayerData(citizenid) if not citizenid then return { points = 0, cancel_streak = 0 } end; local result = MySQL.single.await('SELECT points, cancel_streak FROM player_bartering_points WHERE citizenid = ?', { citizenid }); if result then result.points = tonumber(result.points) or 0; result.cancel_streak = tonumber(result.cancel_streak) or 0 else result = { points = 0, cancel_streak = 0 } end; return result end
local function updateDbPlayerData(citizenid, newPoints, newStreak) if not citizenid then return end; local pointsToSet = newPoints; local streakToSet = newStreak; local currentData; if pointsToSet == nil or streakToSet == nil then currentData = getDbPlayerData(citizenid); if pointsToSet == nil then pointsToSet = currentData.points end; if streakToSet == nil then streakToSet = currentData.cancel_streak end end; pointsToSet = math.max(0, tonumber(pointsToSet) or 0); streakToSet = math.max(0, tonumber(streakToSet) or 0); MySQL.update.await('INSERT INTO player_bartering_points (citizenid, points, cancel_streak) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE points = VALUES(points), cancel_streak = VALUES(cancel_streak)', { citizenid, pointsToSet, streakToSet }); return pointsToSet end
local function addDbPlayerPoints(citizenid, pointsToAdd) if not citizenid then return 0 end; local currentData = getDbPlayerData(citizenid); local newPoints = currentData.points + pointsToAdd; return updateDbPlayerData(citizenid, newPoints, nil) end
local function setDbPlayerPoints(citizenid, points) if not citizenid then return end; updateDbPlayerData(citizenid, points, nil) end
local function resetDbPlayerCancelStreak(citizenid) if not citizenid then return end; updateDbPlayerData(citizenid, nil, 0) end
local function incrementDbPlayerCancelStreak(citizenid) if not citizenid then return 0 end; local currentData = getDbPlayerData(citizenid); local newStreak = currentData.cancel_streak + 1; updateDbPlayerData(citizenid, nil, newStreak); return newStreak end

-- [[ FUNKSIONET E PED-IT TE KONTRATAVE ]]
local function loadPedState() local indexResult = MySQL.scalar.await('SELECT state_value FROM bartering_system_state WHERE state_key = ?', {'current_location_index'}); local contractsResult = MySQL.scalar.await('SELECT state_value FROM bartering_system_state WHERE state_key = ?', {'contracts_at_location'}); currentPedLocationIndex = indexResult and tonumber(indexResult) or 1; contractsCompletedAtCurrentLocation = contractsResult and tonumber(contractsResult) or 0; print(('[xrb-Bartering] Ped State Loaded: Location Index %s, Contracts at Location %s'):format(currentPedLocationIndex, contractsCompletedAtCurrentLocation)) end
local function savePedState() MySQL.update.await('INSERT INTO bartering_system_state (state_key, state_value) VALUES (?, ?) ON DUPLICATE KEY UPDATE state_value = ?', {'current_location_index', currentPedLocationIndex, currentPedLocationIndex}); MySQL.update.await('INSERT INTO bartering_system_state (state_key, state_value) VALUES (?, ?) ON DUPLICATE KEY UPDATE state_value = ?', {'contracts_at_location', contractsCompletedAtCurrentLocation, contractsCompletedAtCurrentLocation}) end
local function movePedToNextLocation() currentPedLocationIndex = currentPedLocationIndex + 1; if currentPedLocationIndex > #Config.PedLocations then currentPedLocationIndex = 1 end; contractsCompletedAtCurrentLocation = 0; savePedState(); print(('[xrb-Bartering] Contract Ped moved to location index %s. Triggering client update.'):format(currentPedLocationIndex)); TriggerClientEvent('xrb-bartering:updatePedLocation', -1, currentPedLocationIndex) end

-- [[ FUNKSIONET E KONTRATES ]]
local function getAvailableContract(playerPoints) local availableTiers = {}; for pointsRequired, contracts in pairs(Config.ContractTiers) do if playerPoints >= pointsRequired then table.insert(availableTiers, { points = pointsRequired, contracts = contracts }) end end; if #availableTiers == 0 then return nil end; table.sort(availableTiers, function(a, b) return a.points > b.points end); local selectedTier = availableTiers[1]; if not selectedTier.contracts or #selectedTier.contracts == 0 then print(('[xrb-Bartering] [WARNING] Selected contract tier (Points >= %d) has no contracts defined!'):format(selectedTier.points)); return nil end; local randomIndex = math.random(1, #selectedTier.contracts); return selectedTier.contracts[randomIndex] end
local function startContractTimer(source, contractId) local contractInfo = playerActiveContracts[source]; if not contractInfo then return end; CreateThread(function() local endTime = contractInfo.endTime; while GetGameTimer() / 1000 < endTime do Wait(1000); local Player = QBCore.Functions.GetPlayer(source); if not Player or not playerActiveContracts[source] or playerActiveContracts[source].contractId ~= contractId then break end end; if playerActiveContracts[source] and playerActiveContracts[source].contractId == contractId then local Player = QBCore.Functions.GetPlayer(source); if Player then local pointsLost = Config.PointsPenaltyFail; local currentData = getDbPlayerData(Player.PlayerData.citizenid); updateDbPlayerData(Player.PlayerData.citizenid, currentData.points - pointsLost, currentData.cancel_streak); print(('[xrb-Bartering] Contract %s for player %s (%s) FAILED due to time limit. Lost %d points.'):format(contractId, source, Player.PlayerData.citizenid, pointsLost)); TriggerClientEvent('ox_lib:notify', source, { title = 'Contract Failed', description = Config.Messages['contract_failed_time']:format(pointsLost), type = 'error' }); TriggerClientEvent('xrb-bartering:contractFailed', source) end; playerActiveContracts[source] = nil end end) end

-- [[ FUNKSIONET E DYQANIT ]]
local function GenerateShopStock(shopId) local shopConfig = nil; for _, shop in ipairs(Config.Shops) do if shop.id == shopId then shopConfig = shop; break end end; if not shopConfig or not shopConfig.potential_items then print(('[xrb-Bartering] [ERROR] No config/items found for shop %s.'):format(shopId)); currentShopStock[shopId] = {}; return false end; local generatedStock = {}; for _, itemData in ipairs(shopConfig.potential_items) do if not QBCore.Shared.Items[itemData.name] then print(('[xrb-Bartering] [WARNING] Item "%s" in shop "%s" does not exist.'):format(itemData.name, shopId)); goto continue_loop end; if math.random(1, 100) <= itemData.chance then local stockAmount = math.random(itemData.min_stock, itemData.max_stock); if stockAmount > 0 then table.insert(generatedStock, { name = itemData.name, price = itemData.base_price, currency = itemData.currency == 'bank' and 'bank' or 'cash', stock = stockAmount }) end end; ::continue_loop:: end; currentShopStock[shopId] = generatedStock; return true end
local function RefreshAllShops() print(Config.Messages['shop_refreshing']); local allSuccess = true; local errorShops = {}; for _, shopConfig in ipairs(Config.Shops) do if not GenerateShopStock(shopConfig.id) then allSuccess = false; table.insert(errorShops, shopConfig.id) end end; if allSuccess then print(Config.Messages['shop_refreshed']) else print(("[xrb-Bartering] [ERROR] Shop refresh completed with errors in shops: %s"):format(table.concat(errorShops, ", "))) end; StartShopRefreshTimer() end
function StartShopRefreshTimer() if shopRefreshTimer then ClearTimeout(shopRefreshTimer); shopRefreshTimer = nil end; local intervalMs = Config.ShopRefreshIntervalMinutes * 60 * 1000; if intervalMs > 0 then shopRefreshTimer = SetTimeout(intervalMs, RefreshAllShops) else print('[xrb-Bartering] Automatic shop refresh is disabled.') end end

-- [[ EVENTET KRYESORE ]]
AddEventHandler('onResourceStart', function(resourceName) if resourceName == GetCurrentResourceName() then SetTimeout(2000, function() loadPedState(); print('[xrb-Bartering] Generating initial shop stock...'); for _, shopConfig in ipairs(Config.Shops) do GenerateShopStock(shopConfig.id) end; StartShopRefreshTimer(); print('[xrb-Bartering] Server resource started.') end) end end)
AddEventHandler('onResourceStop', function(resourceName) if resourceName == GetCurrentResourceName() then savePedState(); if shopRefreshTimer then ClearTimeout(shopRefreshTimer); shopRefreshTimer = nil; print('[xrb-Bartering] Shop refresh timer stopped.') end; print('[xrb-Bartering] Server resource stopped.') end end)

-- ==============================
-- [[ EVENTET E RRJETIT (NET EVENTS) ]]
-- ==============================
RegisterNetEvent('xrb-bartering:requestContract', function() local source = source; local Player = QBCore.Functions.GetPlayer(source); if not Player then return end; if playerActiveContracts[source] then TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['already_active_contract'], type = 'error' }); return end; local playerPoints = getDbPlayerData(Player.PlayerData.citizenid).points; local contractData = getAvailableContract(playerPoints); if not contractData then TriggerClientEvent('ox_lib:notify', source, { title = 'Informacion', description = Config.Messages['no_contracts_available_for_tier'], type = 'info' }); return end; if contractData.points_reward == nil then contractData.points_reward = 0; print(('[xrb-Bartering] [WARNING] Contract %s missing points_reward. Defaulting to 0 for client.'):format(contractData.name or 'N/A')) end; local contractId = ('contract_%s_%s'):format(source, math.random(1000, 9999)); local currentTime = GetGameTimer() / 1000; local endTime = currentTime + (contractData.time_limit * 60); playerActiveContracts[source] = { contractId = contractId, contractData = contractData, endTime = endTime }; TriggerClientEvent('xrb-bartering:contractInfo', source, playerActiveContracts[source]); TriggerClientEvent('ox_lib:notify', source, { title = 'Contract Accepted', description = Config.Messages['contract_accepted']:format(contractData.name, contractData.time_limit), type = 'success' }); startContractTimer(source, contractId) end)
RegisterNetEvent('xrb-bartering:submitItems', function() local source = source; local Player = QBCore.Functions.GetPlayer(source); if not Player then return end; local activeContract = playerActiveContracts[source]; if not activeContract then TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['no_active_contract'], type = 'error' }); return end; if not activeContract.contractData then print(('[xrb-Bartering] [CRITICAL ERROR] submitItems: activeContract.contractData is nil for player %s'):format(source)); playerActiveContracts[source]=nil; TriggerClientEvent('xrb-bartering:contractFailed', source); return end; local hasAllItems = true; local itemsToRemove = {}; local missingItemText = ""; if not activeContract.contractData.required_items then activeContract.contractData.required_items = {} end; for _, req in ipairs(activeContract.contractData.required_items) do local itemInfo = Player.Functions.GetItemByName(req.item); if not itemInfo or itemInfo.amount < req.count then hasAllItems = false; local itemLabel = QBCore.Shared.Items[req.item]?.label or req.item; missingItemText = string.format("Missing: %s (Needed: %d, Has: %d)", itemLabel, req.count, itemInfo and itemInfo.amount or 0); TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['not_enough_items'] .. " (" .. missingItemText .. ")", type = 'error' }); break end; table.insert(itemsToRemove, { item = req.item, count = req.count }) end; if hasAllItems then for _, itemData in ipairs(itemsToRemove) do Player.Functions.RemoveItem(itemData.item, itemData.count) end; local pointsRewardFromConfig = activeContract.contractData.points_reward; local pointsGained = 0; if pointsRewardFromConfig ~= nil then local convertedPoints = tonumber(pointsRewardFromConfig); if type(convertedPoints) == "number" then pointsGained = convertedPoints else print(('[xrb-Bartering] [WARNING] Invalid points_reward type (%s) for contract %s. Value: [%s]. Awarding 0 points.'):format(type(pointsRewardFromConfig), activeContract.contractData.name or 'N/A', tostring(pointsRewardFromConfig))) end else print(('[xrb-Bartering] [WARNING] Missing points_reward for contract %s. Awarding 0 points.'):format(activeContract.contractData.name or 'N/A')) end; local currentPoints = getDbPlayerData(Player.PlayerData.citizenid).points; local newTotalPoints = currentPoints + pointsGained; resetDbPlayerCancelStreak(Player.PlayerData.citizenid); print(('[xrb-Bartering] Cancel streak reset for player %s (%s) after successful contract.'):format(source, Player.PlayerData.citizenid)); local closedContractId = activeContract.contractId or 'N/A'; local closedContractName = activeContract.contractData.name or 'N/A'; local moneyReward = activeContract.contractData.black_money_reward; TriggerClientEvent('xrb-bartering:contractSuccess', source); playerActiveContracts[source] = nil; print(('[xrb-Bartering] Contract %s closed for player %s. Attempting to add %d points.'):format(closedContractId, source, pointsGained)); updateDbPlayerData(Player.PlayerData.citizenid, newTotalPoints, 0); local rewardNotifyTextPart = nil; if moneyReward and moneyReward.amount and moneyReward.amount > 0 then local moneyType = moneyReward.type; local amount = moneyReward.amount; if moneyType == 'cash' then Player.Functions.AddMoney('cash', amount, "bartering-contract-reward"); rewardNotifyTextPart = string.format("$%s CASH", amount) elseif moneyType == 'bank' then Player.Functions.AddMoney('bank', amount, "bartering-contract-reward"); rewardNotifyTextPart = string.format("$%s BANK", amount) elseif moneyType == 'black_money' then local blackMoneyItem = Config.BlackMoneyItemName; if blackMoneyItem and QBCore.Shared.Items[blackMoneyItem] then if Player.Functions.AddItem(blackMoneyItem, amount) then local itemLabel = QBCore.Shared.Items[blackMoneyItem].label or blackMoneyItem; rewardNotifyTextPart = string.format("%sx %s", amount, itemLabel) else Player.Functions.AddMoney('cash', amount, "bartering-contract-reward-fallback"); rewardNotifyTextPart = string.format("$%s CASH (Fallback - Inv Fail)", amount); print(('[xrb-Bartering] [WARNING] Failed add black money item %s (%sx) for contract %s (Player: %s). Giving CASH.'):format(blackMoneyItem, amount, closedContractName, source)) end else Player.Functions.AddMoney('cash', amount, "bartering-contract-reward-fallback"); rewardNotifyTextPart = string.format("$%s CASH (Fallback - Item Fail)", amount); print(('[xrb-Bartering] [WARNING] Black money item "%s" not found/configured for contract %s. Giving CASH.'):format(tostring(blackMoneyItem), closedContractName)) end else Player.Functions.AddMoney('cash', amount, "bartering-contract-reward-fallback"); rewardNotifyTextPart = string.format("$%s CASH (Fallback - Type Fail)", amount); print(('[xrb-Bartering] [WARNING] Unknown reward type "%s" for contract %s. Giving CASH.'):format(moneyType, closedContractName)) end end; local finalNotificationDescription = ""; local pointsGainedNum = pointsGained; if rewardNotifyTextPart then finalNotificationDescription = "Contract completed successfully! You earned " .. pointsGainedNum .. " points and " .. rewardNotifyTextPart .. "." else local success, formattedMsg = pcall(string.format, Config.Messages['contract_success_points'], pointsGainedNum); if success then finalNotificationDescription = formattedMsg else print(('[xrb-Bartering] [ERROR] Failed string.format for points success message. Points: %s, Error: %s'):format(tostring(pointsGainedNum), formattedMsg)); finalNotificationDescription = "Contract completed! Points: " .. pointsGainedNum end end; TriggerClientEvent('ox_lib:notify', source, { title = 'Success', description = finalNotificationDescription, type = 'success' }); contractsCompletedAtCurrentLocation = contractsCompletedAtCurrentLocation + 1; savePedState(); if contractsCompletedAtCurrentLocation >= Config.ContractsPerLocation then movePedToNextLocation() end end end)
RegisterNetEvent('xrb-bartering:requestShopAccess', function(shopId) local source = source; local Player = QBCore.Functions.GetPlayer(source); if not Player then return end; local shopConfig = nil; for _, shop in ipairs(Config.Shops) do if shop.id == shopId then shopConfig = shop; break end end; if not shopConfig then print(('[xrb-Bartering] [ERROR] Player %s tried shop %s - config not found.'):format(source, shopId)); TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = 'Store config error.', type = 'error' }); return end; local playerPoints = getDbPlayerData(Player.PlayerData.citizenid).points; if playerPoints >= shopConfig.required_points then local stockData = currentShopStock[shopId] or {}; TriggerClientEvent('xrb-bartering:openOxLibShop', source, shopConfig.label, stockData, shopId) else TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['not_enough_points_shop']:format(playerPoints, shopConfig.required_points), type = 'error' }) end end)
RegisterNetEvent('xrb-bartering:purchaseShopItem', function(shopId, itemName, itemPrice, currencyType) local source = source; local Player = QBCore.Functions.GetPlayer(source); if not Player then return end; local shopStock = currentShopStock[shopId]; local itemInStock = nil; local itemIndex = -1; if shopStock then for i, item in ipairs(shopStock) do if item.name == itemName then itemInStock = item; itemIndex = i; break end end end; if not itemInStock then print(('[xrb-Bartering] [ERROR] Purchase Fail: Item %s not in server stock for shop %s (Player: %s).'):format(itemName, shopId, source)); TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['shop_purchase_failed_stock'], type = 'error' }); return end; if itemInStock.stock <= 0 then TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['shop_purchase_failed_stock'], type = 'error' }); local csc = nil; for _, s in ipairs(Config.Shops) do if s.id == shopId then csc = s; break end end; if csc then TriggerClientEvent('xrb-bartering:openOxLibShop', source, csc.label, currentShopStock[shopId] or {}, shopId) end; return end; if itemInStock.price ~= itemPrice or itemInStock.currency ~= currencyType then print(('[xrb-Bartering] [SECURITY ALERT] Price mismatch item %s shop %s (Player: %s). Server: %s %s, Client: %s %s'):format(itemName, shopId, source, itemInStock.price, itemInStock.currency, itemPrice, currencyType)); TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['shop_purchase_failed_generic'], type = 'error' }); return end; if not exports.ox_inventory:CanCarryItem(source, itemName, 1) then TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['shop_purchase_failed_inventory'], type = 'error' }); return end; local actualCurrencyType = currencyType == 'bank' and 'bank' or 'cash'; local playerMoney = Player.PlayerData.money[actualCurrencyType]; if playerMoney >= itemPrice then if not Player.Functions.RemoveMoney(actualCurrencyType, itemPrice, "bartering-shop-purchase-"..itemName) then print(('[xrb-Bartering] [ERROR] Failed remove money player %s.'):format(source)); TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['shop_purchase_failed_generic'], type = 'error' }); return end; if not Player.Functions.AddItem(itemName, 1, false) then print(('[xrb-Bartering] [ERROR] Failed add item %s to player %s.'):format(itemName, source)); Player.Functions.AddMoney(actualCurrencyType, itemPrice, "bartering-shop-purchase-refund-"..itemName); TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['shop_purchase_failed_inventory'], type = 'error' }); return end; currentShopStock[shopId][itemIndex].stock = currentShopStock[shopId][itemIndex].stock - 1; local itemLabel = QBCore.Shared.Items[itemName]?.label or itemName; TriggerClientEvent('ox_lib:notify', source, { title = 'Successful Purchase', description = Config.Messages['shop_purchase_success']:format(itemLabel), type = 'success' }); local csc = nil; for _, s in ipairs(Config.Shops) do if s.id == shopId then csc = s; break end end; if csc then TriggerClientEvent('xrb-bartering:openOxLibShop', source, csc.label, currentShopStock[shopId], shopId) end else local moneyMsg = actualCurrencyType == 'bank' and Config.Messages['shop_purchase_failed_money_bank'] or Config.Messages['shop_purchase_failed_money_cash']; TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = moneyMsg, type = 'error' }) end end)
RegisterNetEvent('xrb-bartering:requestInitialState', function() local source = source; local Player = QBCore.Functions.GetPlayer(source); if not Player then return end; TriggerClientEvent('xrb-bartering:receiveInitialState', source, currentPedLocationIndex); if playerActiveContracts[source] then TriggerClientEvent('xrb-bartering:contractInfo', source, playerActiveContracts[source]) end end)

-- [[ COMMAND: /bartering Request Handler ]]
RegisterNetEvent('xrb-bartering:requestStatusCommand', function()
    local source = source
    local Player = QBCore.Functions.GetPlayer(source)
    if not Player then return end

    local playerData = getDbPlayerData(Player.PlayerData.citizenid)
    local currentPoints = playerData.points

    local activeContractInfo = playerActiveContracts[source]
    local contractToSend = nil

    if activeContractInfo and activeContractInfo.contractData then
        contractToSend = {
            contractData = { 
                name = activeContractInfo.contractData.name or "Unknown",
                points_reward = activeContractInfo.contractData.points_reward or 0, 
                required_items = activeContractInfo.contractData.required_items or {}
            },
            endTime = activeContractInfo.endTime
        }
    end

    local statusData = {
        points = currentPoints,
        contract = contractToSend 
    }
    TriggerClientEvent('xrb-bartering:showStatusMenu', source, statusData)
end)


AddEventHandler('playerDropped', function(reason) local source = source; if playerActiveContracts[source] then playerActiveContracts[source] = nil end end)
RegisterNetEvent('xrb-bartering:server:playerDied', function() local source = source; local Player = QBCore.Functions.GetPlayer(source); if not Player then return end; if Config.PointsPenaltyDeath and Config.PointsPenaltyDeath > 0 then local pointsLost = Config.PointsPenaltyDeath; local currentData = getDbPlayerData(Player.PlayerData.citizenid); updateDbPlayerData(Player.PlayerData.citizenid, currentData.points - pointsLost, currentData.cancel_streak); TriggerClientEvent('ox_lib:notify', source, { title = 'Penalties', description = Config.Messages['points_lost_death']:format(pointsLost), type = 'warning' }) end end)

-- [[ ADMIN MENU & COMMANDS ]]
RegisterNetEvent('xrb-bartering:adminModifyPoints', function(targetPlayerId, action, amount) local source = source; local AdminPlayer = QBCore.Functions.GetPlayer(source); if not AdminPlayer or not QBCore.Functions.HasPermission(source, Config.AdminGroup) then print(('[xrb-Bartering] [SECURITY] Player %s tried adminModifyPoints without permission.'):format(source)); return end; local TargetPlayer = QBCore.Functions.GetPlayer(targetPlayerId); if not TargetPlayer then TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['invalid_player'], type = 'error' }); return end; local amountNum = tonumber(amount); if not amountNum or amountNum < 0 then TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['invalid_amount'], type = 'error' }); return end; local targetCitizenId = TargetPlayer.PlayerData.citizenid; local targetName = TargetPlayer.PlayerData.charinfo.firstname .. " " .. TargetPlayer.PlayerData.charinfo.lastname; local adminName = AdminPlayer.PlayerData.charinfo.firstname .. " " .. AdminPlayer.PlayerData.charinfo.lastname; local currentData = getDbPlayerData(targetCitizenId); local newTotalPoints = 0; local success = false; local actionText = ""; local newStreak = currentData.cancel_streak; if action == 'add' then newTotalPoints = currentData.points + amountNum; actionText = "added"; success = true elseif action == 'remove' then newTotalPoints = currentData.points - amountNum; actionText = "removed"; success = true elseif action == 'set' then newTotalPoints = amountNum; actionText = "set"; success = true else print(('[xrb-Bartering] [ERROR] Invalid action "%s" in adminModifyPoints from admin %s.'):format(action, source)); return end; if success then updateDbPlayerData(targetCitizenId, newTotalPoints, newStreak); print(('[xrb-Bartering] [ADMIN] %s (%s) %s %s points for %s (%s). New total: %s'):format(adminName, source, actionText, amountNum, targetName, targetPlayerId, math.max(0, newTotalPoints))); TriggerClientEvent('ox_lib:notify', source, { title = 'Success', description = Config.Messages['admin_points_success']:format(targetName, targetPlayerId), type = 'success' }); if action == 'add' then TriggerClientEvent('ox_lib:notify', targetPlayerId, { title = 'Bartering Points', description = Config.Messages['points_received']:format(amountNum), type = 'inform' }) elseif action == 'remove' then TriggerClientEvent('ox_lib:notify', targetPlayerId, { title = 'Bartering Points', description = Config.Messages['points_lost']:format(amountNum), type = 'warning' }) elseif action == 'set' then TriggerClientEvent('ox_lib:notify', targetPlayerId, { title = 'Bartering Points', description = Config.Messages['points_set_admin']:format(math.max(0, newTotalPoints)), type = 'inform' }) end else TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['admin_points_failed']:format(targetName, targetPlayerId), type = 'error' }) end end)
RegisterCommand('adminbartering', function(source, args, rawCommand) local Player = QBCore.Functions.GetPlayer(source); if not Player then return end; if QBCore.Functions.HasPermission(source, Config.AdminGroup) then local players = {}; local playerList = QBCore.Functions.GetPlayers(); for _, playerId in ipairs(playerList) do local ply = QBCore.Functions.GetPlayer(playerId); if ply then table.insert(players, {source = ply.PlayerData.source, name = ply.PlayerData.charinfo.firstname .. " " .. ply.PlayerData.charinfo.lastname}) end end; TriggerClientEvent('xrb-bartering:openAdminMenu', source, players) else TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['no_permission'], type = 'error' }) end end, true)
RegisterCommand('refreshbartershops', function(source, args, rawCommand) local Player = QBCore.Functions.GetPlayer(source); if not Player then return end; if QBCore.Functions.HasPermission(source, Config.AdminGroup) then print(('[xrb-Bartering] [ADMIN] %s (%s) forced a shop refresh.'):format(Player.PlayerData.name, source)); RefreshAllShops(); TriggerClientEvent('ox_lib:notify', source, { title = 'Admin', description = 'Store stock was manually refreshed and timer reset.', type = 'inform' }) else TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['no_permission'], type = 'error' }) end end, true)

-- [[ Cancel Contract with Streak Logic ]]
RegisterNetEvent('xrb-bartering:requestCancelContract', function() local source = source; local Player = QBCore.Functions.GetPlayer(source); if not Player then return end; local activeContract = playerActiveContracts[source]; if activeContract then local citizenid = Player.PlayerData.citizenid; local currentData = getDbPlayerData(citizenid); local currentStreak = currentData.cancel_streak; local currentPoints = currentData.points; local pointsPenaltyBase = Config.PointsPenaltyCancelBase or 0; local effectiveStreak = math.min(currentStreak, Config.MaxCancelStreakForPenalty or 5); local pointsPenalty = pointsPenaltyBase * (2 ^ effectiveStreak); local closedContractId = activeContract.contractId or 'N/A'; playerActiveContracts[source] = nil; local newPoints = currentPoints; local newStreak = incrementDbPlayerCancelStreak(citizenid); if pointsPenalty > 0 then newPoints = currentPoints - pointsPenalty; updateDbPlayerData(citizenid, newPoints, newStreak); print(('[xrb-Bartering] Player %s (%s) cancelled contract %s. Lost %d points (Streak: %s -> %s). New total: %s'):format(source, citizenid, closedContractId, pointsPenalty, currentStreak, newStreak, math.max(0,newPoints))); TriggerClientEvent('ox_lib:notify', source, { title = 'Warning', description = Config.Messages['contract_cancelled_penalty_streak']:format(pointsPenalty, newStreak), type = 'warning' }) else print(('[xrb-Bartering] Player %s (%s) cancelled contract %s with no point penalty (Streak: %s -> %s).'):format(source, citizenid, closedContractId, currentStreak, newStreak)); TriggerClientEvent('ox_lib:notify', source, { title = 'Kontrata Anuluar', description = Config.Messages['contract_cancelled_success'], type = 'info' }) end; TriggerClientEvent('xrb-bartering:contractFailed', source) else TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['cannot_cancel_no_contract'], type = 'error' }) end end)
